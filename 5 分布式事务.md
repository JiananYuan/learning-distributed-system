系统从单体架构向分布式架构演变，如何把原来单节点事务对上层应用“无感”地转变为分布式事务，是需要解决的问题。这里介绍分布式事务的实现方式及其遇到的问题，对比分布式事务每种解决方案的优缺点。

## 分布式事务

- 传统数据库事务特性：A（原子性）、C（一致性）、I（隔离性）、D（持久性）
- 传统数据库事务将事务处理过程可能会出现的问题从应用层转移到了数据库，减轻了开发人员的负担，对于分布式事务而言，也隐藏了将数据分割在多台服务器上带来的故障处理等复杂问题。
- 可以将分布式事务看成是两种变体，一是数据需要在多个副本上更新，一个分布式事务需要更新所有的副本；二是数据分片，事务跨多个节点，同时还要保证整体数据的一致性和事务的ACID。第二种事务更加常见。
- 就一致性和持久性来说，分布式事务基本和单机系统类似。但就原子性（原子提交）和隔离性（并发控制）来说，实现复杂。这里重点研究分布式事务中实现A和I的方式。

## 原子提交

- 回顾单机事务原子性操作的实现：在文件系统和数据库中，比较流行的方式是基于硬盘原子写和日志文件实现事务原子性。
- 在分布式系统中，原子性的实现更为复杂。分布式事务要求所有节点要么全部生效，要么不在任何一个节点上生效。
- 分布式事务原子性通过原子提交协议来实现，其包含三个属性：协定性（不存在两个进程一个提交事务一个中止事务）、有效性（所有进程都提交事务且无故障发生，则整个系统提交事务）、终止性（若无故障产生，则所有进程或运行正常的进程最终会做出决议）。

### 两阶段提交（2PC）

- 两阶段提交是最经典的原子提交协议。基本思想：仅仅一个请求不足以知道其他节点能否成功提交事务，就再增加一个请求，检查每个节点上的状态能否满足事务正确性，再进行事务操作。
- 两阶段提交有两个角色：参与者（参与执行事务）、协调者（协调算法各个阶段）；两个阶段是：准备阶段（投票阶段）和提交阶段。
- 两阶段提交会有同步阻塞、单点故障、数据不一致、提交阶段不确定等问题，部分开发者认为两阶段提交仍没办法达到需要的安全性保证。
- [点我了解两阶段提交](https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4)

### 三阶段提交

### Paxos提交

### 基于Quorum提交

### Saga事务


## 并发控制

分布式系统实现并发控制的方式和一般系统没有太大的区别，一般有三类：悲观并发控制、乐观并发控制和多版本并发控制。

### 两阶段锁（2PL）

- 2PL属于悲观并发控制，使用锁防止并发事务对数据的影响，实现串行化的隔离级别。
- 根据获得锁和释放锁，将一个事务分为扩张阶段和收缩阶段。扩张阶段：事务上锁但不允许释放锁；收缩阶段：事务释放锁但不允许上锁。
- 2PL可能会引发死锁。（死锁避免、死锁预防、死锁检测）
- 评价：2PL为了正确处理数据，增加了系统负载，降低了数据库的并发性能，且存在死锁风险。

### 乐观并发控制

- 理念：大部分时间，事务冲突的可能性较小，事务顺利完成的可能性比失败的可能性大。重点是放在事务提交时的冲突检查上。

### 多版本并发控制

- 多版本并发控制可以看作是在乐观并发控制的基础上，增加了多个版本（为每个数据项存储多个版本），每个事务读到的都是某个版本的数据项，写操作不覆盖已有的数据，而是创建一个新的版本，直到事务提交后才变为可见。（写操作的事务不会阻塞需要读取相同数据的事务）
- 

## Percolator



## 小结





